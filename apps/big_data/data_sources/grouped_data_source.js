// ==========================================================================
// Project:   BigData
// Copyright: Â©2013 7x7 Software, Inc.
// License:   Licensed under MIT license
// ==========================================================================
/*global BigData */



/** @singleton
  This object acts as the delegate for the sparse array used in the UI.

  Whenever a record is requested that hasn't yet been loaded, the sparse
  array will notify this delegate, which because that sparse array itself is
  backed by another sparse array, this delegate will request the necessary range
  from the backing sparse array.  In this way, we can insert groups on the fly
  without affecting the actual ranges that are used to request from the server.

  Note: You can make the data source the delegate, but because there may be
  multiple sparse arrays, it's nice to keep each delegate as its own object.

  Also, we need two delegates, because we want to request indexes on the
  grouped sparse array and ranges on the backing sparse array.
*/
BigData.groupedArrayDelegate = SC.Object.create({

  /** @private SC.SparseArrayDelegate */
  sparseArrayDidRequestIndex: function (sparseArray, index) {
    var backingSparseArray = sparseArray.get('backingSparseArray'),
      groupIndexes;

    // Adjust the index by the number of letter groups that have been inserted
    // before this index.
    groupIndexes = BigData.backingArrayDelegate.get('groupIndexes');
    if (groupIndexes) {
      index -= groupIndexes.without(index, groupIndexes.get('max') - index).get('length');
    }

    // Fetch the next index on the backing sparse array.
    backingSparseArray.requestIndex(index);
  },

  /** @private SC.SparseArrayDelegate */
  sparseArrayDidReset: function (sparseArray) {
    var backingSparseArray = sparseArray.get('backingSparseArray');

    // Also reset the backing array.
    backingSparseArray.reset();
  },

  /** @private SC.SparseArrayDelegate */
  sparseArrayShouldReplace: function () {
    // We allow replacements on this sparse array because we need to fix up
    // indexes when inserting groups non-linearly.
    return true;
  }

});


/** @singleton
  This object acts as the delegate for the sparse array that is backing the
  grouped sparse array used by the UI.  The backing sparse array doesn't need to
  know about how the data is being grouped and simply needs to fetch a single
  range at a time when requested.

  However, when a new range of data comes in for the backing sparse array, this
  delegate has to also update the backed sparse array.  Because grouping is
  done on demand and because data may not come in sequentially, this is actually
  very complex.  A better alternative would be to have groups come in with
  the data sequentially straight from the server.
*/
BigData.backingArrayDelegate = SC.Object.create({

  /**
    The indexes of letters.
    */
  groupIndexes: null,

  /** @private SC.SparseArrayDelegate protocol */
  sparseArrayDidRequestRange: function (sparseArray, range) {
    var page,
      path,
      query = sparseArray.get('query'),
      rangeWindowSize = sparseArray.get('rangeWindowSize'),
      recArray,
      request,
      start = range.start,
      store = sparseArray.get('store');

    // Because this is a demo, we don't have a real server to feed results.
    // Instead we use a bunch of pre-built static JSON files that we can request
    // as though they were being generated by the server.
    //
    // These files are built into the project, so in order to get the path to
    // any certain page we just have to cache the path to one of the files and
    // adjust it to match the page we're looking for.
    page = start / rangeWindowSize + 1;
    path = sc_static('people_1.json');
    path = path.replace('_1', '_' + page);

    // We don't actually use this, but if we had a real server we'd probably
    // need params like this.
    path = path + '?start=%@&length=%@'.fmt(start, range.length);

    // Generate the request and send it.
    request = SC.Request.getUrl(path)
      .json(true)
      .notify(this, this._requestCompleted, {
        sparseArray: sparseArray,
        range: range,
        query: query,
        store: store
      })
      .send();

    // Since the record array doesn't know that we are paging in data behind
    // the scenes, we'll tell it each time its results are updating.  This
    // will put it in a BUSY_REFRESH state.  This is particularly useful
    // if we want the UI to indicate that more results are loading.
    recArray = store.find(query);
    recArray.storeWillFetchQuery(query);

    SC.info('sparseArrayDidRequestRange: %@ - %@ (people_%@.json) - grouped data source'.fmt(start, start + range.length - 1, page));
  },

  /** @private SC.SparseArrayDelegate protocol */
  sparseArrayDidReset: function () {
    this.set('groupIndexes', null);
    this._letters = null;
  },

  /** @private Callback for sparseArrayDidRequestRange method. */
  _requestCompleted: function (response, params) {
    var body,
      failed = true,
      query = params.query,
      store = params.store;

    if (SC.ok(response)) {

      var range = params.range,
        backingSparseArray = params.sparseArray,
        backingStart,
        groupIndexes = this.get('groupIndexes'),
        groupIndexesToAdd = [],
        groupIndexesToRemove = [],
        groupedStoreKeys = [],
        groupsSoFar,
        letters = this._letters,
        newGroupsSoFar = 0,
        people,
        recArray,
        recordType = query.recordType,
        remainingIndexesLength,
        shiftedIndexes,
        sparseArray = backingSparseArray.get('backedSparseArray'),
        start,
        storeKeys;

      // STEP 1. Fulfill the backing request.
      // Load the data into the store.
      body = response.get('body');
      people = body.people;
      storeKeys = store.loadRecords(recordType, people);

      // Update the backing sparse array.
      start = backingStart = range.start;
      backingSparseArray.provideObjectsInRange({ start: start, length: storeKeys.length }, storeKeys);  // What we just added.
      backingSparseArray.provideLength(body.totalCount);  // Total length (not just what we got this fetch)
      backingSparseArray.rangeRequestCompleted(start);


      // STEP 2. Fulfill the backed request.
      // Create the group indexes lazily.
      if (!groupIndexes) {
        groupIndexes = SC.IndexSet.create();
        groupIndexes.set('source', sparseArray);

        letters = this._letters = {};
      }

      // Our backed array starting point is adjusted by the number of groups so
      // far before the current index.
      remainingIndexesLength = groupIndexes.get('max') - start;
      groupsSoFar = groupIndexes.without(start, remainingIndexesLength).get('length');
      start += groupsSoFar;

      // We do our group insertions based on the knowledge that the records
      // are in alphabetical order.
      for (var i = 0, len = people.length; i < len; i++) {
        var letter = people[i].givenName.charAt(0),
          storeKeyIndex = start + i + newGroupsSoFar,
          storeKey;

        // Check our cache to see if we have this letter yet.
        if (SC.none(letters[letter])) {
          // Insert a group record for this new letter.
          storeKey = store.pushRetrieve(BigData.PersonGroup, SC.guidFor(letter), {
            title: letter
          });
          groupedStoreKeys.push(storeKey);

          // Add the index to the letter group record (this is offset by the
          // number of groups added so far) and track the letter.
          letters[letter] = storeKeyIndex;
          groupIndexesToAdd.push(storeKeyIndex);

          newGroupsSoFar++;  // Track how many new groups have been added.
        } else if (letters[letter] > storeKeyIndex) {
          // If going backwards, we may have already added a group for the
          // letter but now that we've loaded in more results we can see that
          // the group should have been earlier. Remove the old group.
          sparseArray.replace(letters[letter], 1);

          // Move the group record for this letter.
          storeKey = store.storeKeyFor(BigData.PersonGroup, SC.guidFor(letter));
          groupedStoreKeys.push(storeKey);

          // Move the position of our group index accordingly.
          groupIndexesToRemove.push(letters[letter]);
          letters[letter] = storeKeyIndex;
          groupIndexesToAdd.push(storeKeyIndex);
        }

        // Add the person store key.
        groupedStoreKeys.push(storeKeys[i]);
      }


      // Because we aren't loading in fixed ranges, we need to shift
      // all the further contents to fit any new groups that are added.
      if (groupIndexesToAdd.length) {

        // Insert empty space for the extra group objects to fit within.
        sparseArray.replace(start, 0, new Array(groupIndexesToAdd.length));

        // Remove all the moved group indexes.
        groupIndexes.removeEach(groupIndexesToRemove);

        // Shift all the remaining indexes up and out of the way.
        if (newGroupsSoFar > 0) {
          shiftedIndexes = groupIndexes.without(start, remainingIndexesLength);
          groupIndexes.forEachIn(start, remainingIndexesLength, function (idx) {
            shiftedIndexes.add(idx + newGroupsSoFar);
          });
          groupIndexes = shiftedIndexes;
        }

        // Insert all the new group indexes.
        groupIndexes.addEach(groupIndexesToAdd);
      }

      // Update the grouped sparse array.
      sparseArray.provideObjectsInRange({ start: start, length: groupedStoreKeys.length }, groupedStoreKeys); // What we just added
      sparseArray.provideLength(body.totalCount + groupIndexes.get('length')); // Total length (not just what we got this fetch)

      // Pass the updated group indexes information back to the record array
      // and update the results of the query in order to set the RecordArray
      // status back to READY.
      recArray = store.find(query);
      recArray.set('groupIndexes', groupIndexes);
      store.dataSourceDidFetchQuery(query, sparseArray);

      // The other delegate needs to know the group indexes that are in use.
      this.set('groupIndexes', groupIndexes);

      SC.info('   _requestCompleted: %@ - %@ (%@ - %@)'.fmt(start, start + groupedStoreKeys.length - 1, backingStart, backingStart + storeKeys.length - 1));

      failed = false;
    }

    // Typically you would want to throw some kind of error message here or retry.
    if (failed) {
      SC.error("Unable to retrieve range: %@".fmt(query));
      store.dataSourceDidErrorQuery(query, response);
    }
  }

});


/** @singleton
  This data source pages in data from the server as necessary and inserts
  group records on the fly.  This way we can group our data using just a
  little bit of known information (i.e. that the responses are sorted in
  alphabetical order).

  In order to have our results array be the sparsely loaded and grouped data
  we back it with another sparse array that is the flat data.

  @extends DataSource
*/
BigData.groupedDataSource = SC.DataSource.create({

  /**
    Fetch is called when someone runs a query on the store.
  */
  fetch: function (store, query) {
    var handled = false,
      recordType = query.recordType,
      backingSparseArray,
      sparseArray;

    // We handle the request if we're the active data source.
    if (recordType === BigData.Person && query.targetDataSource === 'groupedDataSource') {
      // This sparse array will contain group keys and will be backed by another
      // sparse array that will actually load in data.
      sparseArray = SC.SparseArray.create({
        delegate: BigData.groupedArrayDelegate
      });

      // We will create a sparse array for the store keys so that we can page in
      // data lazily as necessary. We use 100 as the rangeWindowSize, because
      // our simulated server responses are always 100 items long.
      backingSparseArray = SC.SparseArray.create({
        backedSparseArray: sparseArray,
        delegate: BigData.backingArrayDelegate,
        query: query,
        rangeWindowSize: 100,
        store: store
      });

      // Add a reference back to the backing sparse array.
      sparseArray.set('backingSparseArray', backingSparseArray);

      // Requesting the first index will start loading the initial range of
      // records immediately.
      backingSparseArray.requestIndex(0);

      // Indicate that we took this request.
      handled = true;
    }

    return handled;
  }

});
